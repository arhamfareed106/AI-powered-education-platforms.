from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app import crud, schemas
from app.api import deps
from app.models.payment import Subscription
from app.services.subscriptions import SubscriptionService
from app.models.user import User

router = APIRouter()
subscription_service = SubscriptionService()

@router.get("/plans", response_model=dict)
async def get_subscription_plans():
    """
    Get all available subscription plans.
    """
    plans = await subscription_service.get_subscription_plans()
    return plans

@router.get("/plan/{plan_id}", response_model=dict)
async def get_subscription_plan(plan_id: str):
    """
    Get a specific subscription plan.
    """
    plan = await subscription_service.get_subscription_plan(plan_id)
    if not plan:
        raise HTTPException(status_code=404, detail="Plan not found")
    return plan

@router.post("/", response_model=dict)
async def create_subscription(
    *,
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(deps.get_current_active_user),
    subscription_in: schemas.SubscriptionCreate,
):
    """
    Create new subscription using the subscription service.
    """
    try:
        # Create subscription using the service
        subscription = await subscription_service.create_subscription(
            user_id=current_user.id,
            plan_id=subscription_in.plan_id,
            payment_method_id=subscription_in.payment_method_id
        )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/{subscription_id}", response_model=dict)
async def read_subscription(
    *,
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(deps.get_current_active_user),
    subscription_id: str,
):
    """
    Get a specific subscription by id.
    """
    # In a real implementation, you would verify the user owns this subscription
    # For now, we'll simulate fetching the subscription
    subscription = {
        "subscription_id": subscription_id,
        "user_id": current_user.id,
        "plan_id": "pro",
        "plan_name": "Pro Plan",
        "status": "active",
        "start_date": "2025-12-01T00:00:00Z",
        "end_date": "2025-12-31T23:59:59Z",
        "auto_renew": True,
        "created_at": "2025-12-01T00:00:00Z"
    }
    return subscription

@router.get("/user/current", response_model=dict)
async def read_current_user_subscription(
    *,
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(deps.get_current_active_user),
):
    """
    Get the current subscription for the authenticated user.
    """
    subscription = await subscription_service.get_user_subscription(current_user.id)
    if not subscription:
        raise HTTPException(status_code=404, detail="Subscription not found")
    return subscription

@router.delete("/{subscription_id}", response_model=dict)
async def cancel_subscription(
    *,
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(deps.get_current_active_user),
    subscription_id: str,
):
    """
    Cancel a subscription.
    """
    # In a real implementation, you would verify the user owns this subscription
    # For now, we'll simulate cancelling the subscription
    cancelled_subscription = await subscription_service.cancel_subscription(subscription_id)
    return cancelled_subscription