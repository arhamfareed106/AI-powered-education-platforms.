from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app import crud, schemas
from app.api import deps
from app.core.config import settings
from app.models.user import User
from app.auth.service import AuthService
from datetime import timedelta

router = APIRouter()
auth_service = AuthService()

@router.post("/signup", response_model=schemas.User)
async def signup(
    *,
    db: Session = Depends(deps.get_db),
    user_in: schemas.UserCreate,
) -> User:
    """
    Create new user using the auth service.
    """
    # Check if user already exists
    existing_user = crud.get_user_by_email(db, email=user_in.email)
    if existing_user:
        raise HTTPException(
            status_code=400,
            detail="The user with this email already exists in the system.",
        )
    
    # Register user using auth service
    user_data = await auth_service.register_user(
        email=user_in.email,
        password=user_in.password,
        name=user_in.name,
        role=user_in.role or "student"
    )
    
    # Create user in database
    user = crud.create_user(db, user=user_in)
    return user

@router.post("/login", response_model=schemas.Token)
async def login(
    *,
    db: Session = Depends(deps.get_db),
    user_in: schemas.UserLogin,
) -> dict:
    """
    OAuth2 compatible token login, get an access token for future requests using the auth service.
    """
    # Authenticate user using auth service
    user_data = await auth_service.authenticate_user(user_in.email, user_in.password)
    if not user_data:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Get user from database
    user = crud.get_user_by_email(db, email=user_in.email)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Create access token
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = auth_service.create_access_token(
        data={"user_id": user.id, "role": user.role}, expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=schemas.User)
def read_user_me(
    current_user: User = Depends(deps.get_current_active_user),
) -> User:
    """
    Get current active user.
    """
    return current_user

@router.post("/refresh", response_model=schemas.Token)
def refresh_token(
    current_user: User = Depends(deps.get_current_active_user),
) -> dict:
    """
    Refresh access token
    """
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = auth_service.create_access_token(
        data={"user_id": current_user.id, "role": current_user.role}, expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/verify-token", response_model=dict)
async def verify_token(
    token: str,
) -> dict:
    """
    Verify a JWT access token.
    """
    payload = auth_service.verify_access_token(token)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    return {"valid": True, "payload": payload}